<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>对优雅地发送电子邮件的探索</title>
      <link href="/post/7917a08b/"/>
      <url>/post/7917a08b/</url>
      
        <content type="html"><![CDATA[<h2 id="1-电子邮件相关概念"><a href="#1-电子邮件相关概念" class="headerlink" title="1. 电子邮件相关概念"></a>1. 电子邮件相关概念</h2><h3 id="1-E-mail是什么？"><a href="#1-E-mail是什么？" class="headerlink" title="1) E-mail是什么？"></a>1) E-mail是什么？</h3><p>按照<a href="https://zh.wikipedia.org/wiki/电子邮件" target="_blank" rel="noopener">电子邮件 - 维基百科</a>的说法，电子邮件定义是：</p><blockquote><p>一种由一寄件人将数字信息发送给一个人或多个人的信息交换方式</p></blockquote><h3 id="2-SMTP是什么？"><a href="#2-SMTP是什么？" class="headerlink" title="2) SMTP是什么？"></a>2) SMTP是什么？</h3><p>按照<a href="https://zh.wikipedia.org/wiki/简单邮件传输协议" target="_blank" rel="noopener">简单邮件传输协议 - 维基百科</a>的说法，SMTP定义是：</p><blockquote><p><strong>简单邮件传输协议</strong>（英语：<strong>S</strong>imple <strong>M</strong>ail <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：<strong>SMTP</strong>）是一个在<a href="https://zh.wikipedia.org/wiki/網際網路" target="_blank" rel="noopener">互联网</a>上传输<a href="https://zh.wikipedia.org/wiki/電子郵件" target="_blank" rel="noopener">电子邮件</a>的标准。</p></blockquote><p>简单来说，SMTP协议就是一个基于TCP/IP的、专门用于发送电子邮件的应用层协议。</p><h3 id="3-电子邮件送达率的意义？"><a href="#3-电子邮件送达率的意义？" class="headerlink" title="3) 电子邮件送达率的意义？"></a>3) 电子邮件送达率的意义？</h3><p>不同于国内，在国外SMS（Short Message Service，短消息服务）其实使用没有国内这么广泛。国外网站很多和用户的交互仍然是通过电子邮件的。而ToC的邮件</p><p>ToC： <strong>OTA发货/退款成功后，给到用户的通知邮件</strong>。</p><p>ToB： <strong>对账</strong></p><p>这些场景对邮件送达率和送达时延的要求非常高。试想一下：</p><ul><li>付钱买了机票火车票之后，票的相关信息一直没收到，或者是发车/起飞后你才收到</li><li>和供应商对账约定好是十一点之前需要将对账结果以邮件形式发给他们，然而供应商没有收到或者收到时间非常滞后，导致他们按照合同认为我们昨天没有订单然后进行结算。</li></ul><p>这些场景下，邮件的<strong>送达率</strong>要求是<strong>越接近100%越好</strong>，而<strong>送达时延</strong>是要求<strong>越接近0越好</strong>。</p><h2 id="2-如何优雅地让用户收到邮件？"><a href="#2-如何优雅地让用户收到邮件？" class="headerlink" title="2. 如何优雅地让用户收到邮件？"></a>2. 如何优雅地让用户收到邮件？</h2><p>聊完邮件究竟在我们的业务场景会用来干什么，那么如何达成我们的目标–邮件的<strong>送达率</strong>要求是<strong>越接近100%越好</strong>，而<strong>送达时延</strong>是要求<strong>越接近0越好</strong>，就成为了另一个问题。</p><h3 id="1-选择SMTP服务"><a href="#1-选择SMTP服务" class="headerlink" title="1) 选择SMTP服务"></a>1) 选择SMTP服务</h3><p>因为发送邮件基于SMTP协议，送达率和送达时延很大程度上基于中间的SMTP服务是否稳定和高可用。所以我们的第一个解决思路是找到靠谱的SMTP服务。</p><ul><li><a href="https://mail.google.com/" target="_blank" rel="noopener">Google Mail</a>（目前世界上最大的邮件服务提供商，截至2018年拥有15亿用户)</li><li><a href="https://www.mailgun.com/" target="_blank" rel="noopener">MailGun</a> (MailGun是一个第三方邮件服务网关，提供各种各样的API来方便用户提供服务)</li></ul><p>前者Gmail自身就是最大的邮件服务提供者，它的邮件送达率也比一般意义上的SMTP服务高一些。并且也能最优雅和简单地通过各个邮件服务提供商如Microsoft Outlook和Yahoo Mail等设置的风控和白名单等Anti-Fraud手段。</p><p>而后者是一个基于API的集成了发送、接收和追踪电子邮件等功能的邮件发送服务商，具体的介绍可以在这里看到<a href="https://en.wikipedia.org/wiki/Mailgun" target="_blank" rel="noopener">MailGun</a></p><p>我们知道电商场景下，本身和用户的信息交互就会比较多。另外一个角度来看，国外的通知服务并不像国内这样习惯使用SMS（Short Message Service，短信息服务）进行交互。邮件仍然是国外主要的通知交互手段。</p><h3 id="2-优雅地通过Anti-Fraud"><a href="#2-优雅地通过Anti-Fraud" class="headerlink" title="2) 优雅地通过Anti-Fraud"></a>2) 优雅地通过Anti-Fraud</h3><p>读到这里是不是有一些疑问：</p><ul><li>按照上面的说法，邮件不是正常的保障其符合SMTP协议，然后网络通畅将就可以将其正确的送达收件人的邮箱么？为什么网络的SLA在可以做到三四个甚至五个9的情况（理想情况，并不是指实际业务情况）下，邮件送达率连两个9都不能到达呢？</li></ul><p>原因其实很真实，因为除了网络的因素之外，现代的电子邮件系统已经建立了强大的风控系统。</p><p>这里大家可以去体验一下自建服务：Github上随机找一个开箱可用的SMTP服务项目（如果自带了绕过风控检测的组件，关掉它。），run起来之后配置下DNS，然后发100封邮件给QQ、Outlook、Gmail这些开放式邮箱服务提供商。最后统计一下送达率，你会惊讶的发现，即使你只发送一个hello world，没有任何敏感词，你的邮件仍然会很容易让收件人收不到，即使收到了，也有很大概率在收件人的垃圾箱里面。</p><p>自建SMTP送达率低的情况为什么会出现，其实主要是现在的大型邮件服务提供商，都有通过判断发信人可信度的方式，来判定一封邮件是否是垃圾邮件的检查措施。这部分的技术主要有微软的Sender ID、雅虎的DomainKeys、网易的Spam Feedback等技术。但是判断发信人来源是否可信，只是众多反垃圾邮件手段其中的一项。现代反垃圾邮件系统，同时也会通过判断邮件内容是否有敏感词等等手段，来判断这封邮件是否是一封垃圾邮件。</p><p>总结一下，Anti-Fraud 对于邮件送达率的打击会比较高。因此正确地编写通知邮件内容、控制发送频率和使用稳定而可信的SMTP等对通过Anti-Fraud就显得至关重要。</p><blockquote><p>有兴趣的同学可以继续参看：<a href="https://www.zhihu.com/question/19574247" target="_blank" rel="noopener">怎么样才能让自己服务器发出的邮件不被 Gmail、Hotmail、163、QQ 等邮箱放入垃圾箱？</a>，里面的回答普遍质量比较高。</p></blockquote><h3 id="3-优雅地使用SMTP"><a href="#3-优雅地使用SMTP" class="headerlink" title="3) 优雅地使用SMTP"></a>3) 优雅地使用SMTP</h3><p>讲完了选择SMTP和如何绕开Anti-Fraud之后，还有一个至关重要的部分也需要注意：优雅地调用SMTP服务。这部分有以下几点需要注意：</p><ol><li>SMTP本身是一个基于TCP/IP的网络协议。SMTP服务器也和其他中间件一样，是需要通过网络调用的。对于存在网络调用的场景，就不可避免的谈到一点：调用开销。如果上传的文件比较大，而出口带宽又比较小时，就需要注意此时<strong>发送邮件设置的超时时间是否合理</strong>，是否足够邮件附件上传完成。</li><li><strong>SMTP服务器对附件大小有限制</strong>，对市面上的大部分邮件服务而言，附件限制都是<strong>25M</strong>。如果超过大小限制，建议是使用第三方存储服务来进行文件传递，邮件上只附上下载方式即可。</li><li><strong>SMTP服务器对邮件发送频率和发送上限也会有限制</strong>。对于Gmail，可以查看<a href="https://support.google.com/a/answer/166852" target="_blank" rel="noopener">Google Workspace 中的 Gmail 发送上限 - Google Workspace 管理员帮助</a>，按照文档里的描述，Gmail的每日发送上限是2000。并且这个24小时<strong>并不是自然天</strong>，而是滚动的24小时。也就是说Gmail的发送频率限制实际上是<strong>2000封/24小时</strong>。</li><li><strong>SMTP服务器的调用ip需要稳定</strong>。Gmail的风控手段之一是：客户端数量限制。而这个客户端数量是以<strong>调用Gmail SMTP的ip数</strong>来确定的。同时由于现在hub的分布式部署，即使同一个实例，有可能在调用Gmail SMTP时，仍然有可能使用了不同的ip，造成Google的风控认为多点登录从而将账号短暂封禁。因此建议在使用Gmail时，通过固定IP进行调用。降低被风控的可能性。</li></ol><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><p><a href="https://support.google.com/a/topic/9202?hl=zh-Hans&ref_topic=9197" target="_blank" rel="noopener">Gmail - Google Workspace 管理员帮助</a></p><p><a href="https://www.zhihu.com/question/19574247" target="_blank" rel="noopener">怎么样才能让自己服务器发出的邮件不被 Gmail、Hotmail、163、QQ 等邮箱放入垃圾箱？</a></p><p>Wikipedia</p>]]></content>
      
      
      
        <tags>
            
            <tag> 摸爬滚打 </tag>
            
            <tag> Email </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记之回溯算法</title>
      <link href="/post/41798c93/"/>
      <url>/post/41798c93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段时间一直在笔试面试的循环中，属实心力憔悴。但是在刷题的过程中也发现了一些自己的不足，比如算法方面的二叉树、动态规划和回溯，这一块为了更好地提升自己，所以想总结一下不断刷题解的心得，作为刷题的笔记之一。</p><h2 id="回溯算法本身"><a href="#回溯算法本身" class="headerlink" title="回溯算法本身"></a>回溯算法本身</h2><p>回溯算法的核心思想其实比较容易理解，简单来说：排列组合+合理的剪枝，剪去中途就发现不可能的样例然后往回走从而达到降低时间-空间复杂度的目的。举个比较简单的例子，123这三个数字的排列有几个？在看到这个问题的时候我们会先将一个一个元素视为单一定点。然后先拿出1作为第一个元素的时候，考虑第二个元素在2的情况下，那么第三个元素就应该是3，那么这就是一个合理的组合123。如果是2的话122。是一个不合理的排列，我们抛弃掉这个元素，然后继续寻找下一个排列。以上就是一个简单的追踪-剪枝过程。以下面流程图作为一个简单的总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（2，3同理，这里没有画下去，只是一个简单的流程）</span><br><span class="line">开始</span><br><span class="line">| \ \ </span><br><span class="line">1  2 3</span><br><span class="line">| \ </span><br><span class="line">2  3</span><br><span class="line">| \ </span><br><span class="line">3 2</span><br><span class="line">  |</span><br><span class="line">  (此时2不合理，所以这条枝不会被记录到最终的结果集因而去掉)</span><br></pre></td></tr></table></figure><p>在实际的场景中，一般是伴随着复杂的剪枝条件和大量的组合数据进行分析，从而得出回溯时合适的剪枝点，以及需要记录的上下文。总结一下就是，回溯算法比较像是说一个精简的穷举法。</p><p>接下来先上一个经典题吧<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">leetcode 46:全排列</a>。</p><blockquote><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: [1,2,3]</span><br><span class="line">&gt;输出:</span><br><span class="line">&gt;[</span><br><span class="line"> [1,2,3],</span><br><span class="line"> [1,3,2],</span><br><span class="line"> [2,1,3],</span><br><span class="line"> [2,3,1],</span><br><span class="line"> [3,1,2],</span><br><span class="line"> [3,2,1]</span><br><span class="line">&gt;]</span><br></pre></td></tr></table></figure></blockquote><p>对于这道题而言，因为给出的case里面是没有重复字符的，也就是说我们需要考虑的剪枝条件就是每个数字是否被用过了第二次，如果用过了，则返回上一层试下一个数字。在当前状态机也就是暂存排列情况的队列达到case的长度的时候，视为一个通过情况，并且将其加入结果集。当全部枝被遍历完之后，即得到所有情况的时候，则是得到了想要的排列情况集。用伪代码描述来看就是(灵感来自于 <a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/" target="_blank" rel="noopener">扒一扒回溯算法的裤子 via labuladong</a>)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for 字符 in 字符列表:</span><br><span class="line">    # 选择字符</span><br><span class="line">    将该字符从字符列表移除</span><br><span class="line">    路径.add(字符)</span><br><span class="line">    backtrack(路径, 当前字符列表)</span><br><span class="line">    # 撤销选择</span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入字符列表</span><br></pre></td></tr></table></figure><p>对于backtrack函数而言：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if 路径长度&#x3D;&#x3D;case长度:</span><br><span class="line">    result.add(路径)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">for 字符 in 当前字符列表:</span><br><span class="line">    做选择</span><br><span class="line">    backtrack(路径, 当前字符列表)</span><br><span class="line">    撤销选择</span><br></pre></td></tr></table></figure><p>两段伪代码下来，全排列的框架基本上就搭建完成了。然后是完整代码，这个时候其实只需要基于上面的伪代码进行些许修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">      <span class="comment">// 记录「路径」</span></span><br><span class="line">      LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      backtrack(nums, track);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 路径：记录在 track 中</span></span><br><span class="line">  <span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line">  <span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 触发结束条件</span></span><br><span class="line">      <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">          res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">          <span class="comment">// 排除不合法的选择</span></span><br><span class="line">          <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          <span class="comment">// 做选择</span></span><br><span class="line">          track.add(nums[i]);</span><br><span class="line">          <span class="comment">// 进入下一层决策树</span></span><br><span class="line">          backtrack(nums, track);</span><br><span class="line">          <span class="comment">// 取消选择</span></span><br><span class="line">          track.removeLast();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实整体比较简单，因为这里设计的剪枝条件和数据量都不是很大。接下来看一下稍微复杂一点的<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">leetcode 47:全排列2</a></p><blockquote><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: [1,1,2]</span><br><span class="line">&gt;输出:</span><br><span class="line">&gt;[</span><br><span class="line"> [1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]</span><br><span class="line">&gt;]</span><br></pre></td></tr></table></figure></blockquote><p>对于这道题而言，比较麻烦的是剪枝的时候需要考虑到某个字符是否被用过，如果被用过的话，是第几次被用过，从而不进行重复的追溯。即剪枝代码是：<br>(from <a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">回溯搜索 + 剪枝 via liweiwei1419</a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剪枝条件：i &gt; 0 是为了保证 nums[i - 1] 有意义</span></span><br><span class="line">    <span class="comment">// 写 !used[i - 1] 是因为 nums[i - 1] 在深度优先遍历的过程中刚刚被撤销选择</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.addLast(nums[i]);</span><br><span class="line">    used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    dfs(nums, len, depth + <span class="number">1</span>, used, path, res);</span><br><span class="line">    <span class="comment">// 回溯部分的代码，和 dfs 之前的代码是对称的</span></span><br><span class="line">    used[i] = <span class="keyword">false</span>;</span><br><span class="line">    path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从代码里面看到，主要增加的是对于某个字符是否使用过的剪枝。区别就在于主要是添加used[i]来判断字符是否被用过,然后再添加上一个样例中对于长度的剪枝和判断，则生成了对于这个问题的题解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总而言之，回溯算法的核心思想就是深度遍历+剪枝。但是由于回溯算法的特殊性，尤其要注意回溯时空间复杂度。最后是一些回溯算法经典题目：</p><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number" target="_blank" rel="noopener">17.电话号码的字母组合</a><br><a href="https://leetcode-cn.com/problems/combination-sum" target="_blank" rel="noopener">39. 组合总和</a><br><a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">40. 组合总和 II</a><br><a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">51. N皇后</a><br><a href="https://leetcode-cn.com/problems/permutation-sequence" target="_blank" rel="noopener">60. 第k个排列</a><br><a href="https://leetcode-cn.com/problems/subsets" target="_blank" rel="noopener">78. 子集</a><br><a href="https://leetcode-cn.com/problems/subsets-ii" target="_blank" rel="noopener">90. 子集 II</a>    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纪念一下今日</title>
      <link href="/post/4a17b156/"/>
      <url>/post/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>我向来不是一个善于抒情的人，今天是人生中过的第5个2.29。想想再过不久就要21，纪念一下今天，四年之后，回头再看。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 瞎扯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用smartdns和docker搭建私有防劫持dns服务</title>
      <link href="/post/a62e21c9/"/>
      <url>/post/a62e21c9/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近在家使用移动宽带，使用的ISP DNS出现了DNS的污染，经常会将域名错误解析来劫持域名，十分烦恼。由于DNS本身使用的UDP协议是先到先得，也就是先应答的报文会被视为有效报文。研究了一下ISP的DNS抢答部署，发现是在光猫一级。最开始是希望使用chromium的DNS over https功能，但是还有个问题是其他的设备或者软件使用时，还是会被劫持。因此研究了一下，在windows上搭建一个私有的DNS服务。</p><p>我的需求大概是以下几点：</p><ol><li><p>能够使用DNS over TLS/DNS over https作为上游</p><p> 这点非常重要，因为DNS抢答发生在光猫一级的时候，如果还使用UDP协议作为上游，也就意味着这一层私有DNS向上拿到的仍然是被劫持的结果。</p></li><li><p>方便部署</p><p> 这一点主要是为了方便迁移平台，因为我的目的是让所有使用的设备都能使用这个服务。而不需要对于不同平台弄不同的解决方案。</p></li></ol><p>综合上面两点主要的需求，我找了几个比较热门的解决方案.其中最多人在用的应该是<a href="https://abbypan.github.io/2017/10/11/dnsmasq-dnscrypt-dnswrapper" target="_blank" rel="noopener">dnsmasq+dnscrypt</a>。这种方案的好处显而易见，就是用户群体大，维护方便，相对来说不需要自己太多折腾。但是缺点是dnscrypt不支持指定ISPDNS，这样会使得CDN失效。这样对于访问速度而言伤害比较大。对此，幸运的找到了<a href="https://github.com/pymumu/smartdns" target="_blank" rel="noopener">smartdns</a>项目。它最符合我需求的一点就是</p><blockquote><ol><li><strong>多DNS上游服务器</strong><br>支持配置多个上游DNS服务器，并同时进行查询，即使其中有DNS服务器异常，也不会影响查询。  </li><li><strong>返回最快IP地址</strong><br>支持从域名所属IP地址列表中查找到访问速度最快的IP地址，并返回给客户端，提高网络访问速度。</li><li><strong>支持多种查询协议</strong><br>支持UDP，TCP，TLS, HTTPS查询，以及非53端口查询。</li></ol></blockquote><p>其他特性参见<a href="https://github.com/pymumu/smartdns" target="_blank" rel="noopener">https://github.com/pymumu/smartdns</a></p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>smartdns本身支持了很多部署方式例如deb包、ipk包路由器固件等等。在官方的部署方式中亦给出了WSL子系统的部署方式。并且给出了脚本来进行部署。但是我在尝试了WSL的子系统方式部署后，发现一个问题是，WSL由于隐藏了比较多的细节，或者说实现的比较复杂，出现问题之后比较难debug。因为之前本机部署redis服务的时候，在Windows下搭建了一个docker。因此就试着</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search smartdns</span><br></pre></td></tr></table></figure><p>然后就发现了<a href="https://blog.ghostry.cn/server/894.html" target="_blank" rel="noopener">ghostry/smartdns</a>这个镜像。因为这个作者本身也是smartdns的使用者，于是将其打包成了镜像，并且上传到docker hub。</p><p>对于smartdns的docker搭建，因为有了这个镜像简单了很多，只需要：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//拉取镜像</span><br><span class="line">docker pull ghostry/smartdns</span><br><span class="line">//这两条命令是为了清除掉容器中已经有的同名镜像，防止出错。</span><br><span class="line">docker container stop gsmartdns</span><br><span class="line">docker container rm gsmartdns </span><br><span class="line">//以后台模式运行在53端口，并且设置自动启动，这里也可以监听853或者5353实现自建DNS over TLS或者DNS over TCP等等。</span><br><span class="line">docker run -d -p 53:53/udp --restart=always --name gsmartdns ghostry/smartdns</span><br></pre></td></tr></table></figure><p>在上述命令运行成功之后，<a href="https://blog.ghostry.cn/" target="_blank" rel="noopener">ghostry</a>的docker镜像中原来就已经配置好了一份，但是没有包含被污染的ip列表，以及使用的上游DNS等等。这里上一份我自行修改之后的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">conf-file blacklist-ip.conf</span><br><span class="line">conf-file gfw.conf</span><br><span class="line"></span><br><span class="line">bind [::]:53</span><br><span class="line">bind :53</span><br><span class="line">cache-size 4096                       </span><br><span class="line">prefetch-domain yes                   </span><br><span class="line">speed-check-mode tcp:80,tcp:443,ping  </span><br><span class="line">rr-ttl-min 60                         </span><br><span class="line">rr-ttl-max 86400</span><br><span class="line">log-level warn</span><br><span class="line"></span><br><span class="line">#这两个是我的ISP提供的DNS 用于获取国内的CDN地址 可以换成自己的ISPDNS或者删除</span><br><span class="line">server 211.141.90.68:53  -blacklist-ip -check-edns -group isp</span><br><span class="line">server 211.141.85.68:53  -blacklist-ip -check-edns -group isp</span><br><span class="line">#国内public dns 114 dnspod</span><br><span class="line">server 114.114.114.114:53 -group chinapub</span><br><span class="line">server 119.29.29.29:53 -group chinapub</span><br><span class="line">#google</span><br><span class="line">server 8.8.8.8 -blacklist-ip -group foreign</span><br><span class="line">#cloudflare</span><br><span class="line">server 1.0.0.1 -blacklist-ip -group foreign</span><br><span class="line">#dot doh方式查询</span><br><span class="line">server-tls 1.0.0.1 -group gfw</span><br><span class="line">server-tls 8.8.4.4 -group gfw</span><br><span class="line">server-https https:&#x2F;&#x2F;cloudflare-dns.com&#x2F;dns-query -group gfw</span><br></pre></td></tr></table></figure><p>其中blacklist-ip.conf文件我使用的是这一份<a href="https://gist.github.com/simonsmh/2a609e0c801acabc2e1d7733432bce4c" target="_blank" rel="noopener">blacklist-ip.conf</a>，配置的参数含义参见<a href="https://github.com/pymumu/smartdns" target="_blank" rel="noopener">https://github.com/pymumu/smartdns</a></p><p>在完成以上的配置步骤之后，就可以尝试将DNS改为127.0.0.1进行测试啦。</p><p>关于ISPDNS，记得对nameserver进行配置</p><h2 id="参照"><a href="#参照" class="headerlink" title="参照"></a>参照</h2><ul><li><a href="https://github.com/pymumu/smartdns" target="_blank" rel="noopener">https://github.com/pymumu/smartdns</a></li><li><a href="https://blog.ghostry.cn/server/894.html" target="_blank" rel="noopener">https://blog.ghostry.cn/server/894.html</a></li><li><a href="https://abbypan.github.io/2017/10/11/dnsmasq-dnscrypt-dnswrapper" target="_blank" rel="noopener">https://abbypan.github.io/2017/10/11/dnsmasq-dnscrypt-dnswrapper</a></li></ul><p>我的使用配置文件在 &lt;../assets/blacklist-ip.conf&gt; &lt;../assets/gfw.conf&gt; &lt;../assets/config.conf&gt; 需要的话可以自取</p>]]></content>
      
      
      
        <tags>
            
            <tag> 摸爬滚打 </tag>
            
            <tag> docker </tag>
            
            <tag> dns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短网址服务YOURLS的一些踩坑</title>
      <link href="/post/dcd86f57/"/>
      <url>/post/dcd86f57/</url>
      
        <content type="html"><![CDATA[<p>手上有个yrx.me的域名是之前在<a href="https://yrx.me/s/amh5i3" target="_blank" rel="noopener">https://hover.com</a>一刀注册来的，注册之后才发现.me域名压根不能备案，只好用回了.com的域名。但是这个.me域名一年续费有点小贵（<a href="https://yrx.me/s/w2x4b6" target="_blank" rel="noopener">https://tld-list.com</a>里面ICANN的一级服务商最低的都已经是porkbun的12.99刀了，也有可能是我时间没挑对。。。总而言之选了porkbun作为下一年的接盘侠），于是准备将这个域名用起来。因为不能备案，也就不能解析到国内机器，不然就是一波service hold。正好这边Google cloud的300刀赠金还在，于是准备在GCP-HK放个自己的短链接服务，以防各类短网址服务商的服务不稳定（感叹一下果然还是自己动手丰衣足食）。</p><p>因为这次需要部署一个有GUI的成熟服务，所以没想自己写了，网上找了一圈，看到一个比较靠谱的<a href="https://yrx.me/s/xa6mne" target="_blank" rel="noopener">YOURLS</a>项目。这是一个基于PHP的项目，是一个比较成熟的短网址部署，我的几个需求：1. GUI 2.自定义网址 3.我熟悉的语言（方便debug和后面自己做私有化开发）都有满足。所以选择了这个项目进行部署。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装前置要求是需要NMP/AMP环境，官方使用的是Apache。</p><p>部署过程这里是参考<a href="https://yrx.me/s/z1wu6g" target="_blank" rel="noopener">短网址程序YOURLS安装配置与设置中文</a>的教程。写的比较详细。</p><h2 id="深坑"><a href="#深坑" class="headerlink" title="深坑"></a>深坑</h2><p>如果你和我用的一样是nginx，并且上面这篇文章处理.htacess的方法对你没有用的话，你可以试试将下面这段写入nginx站点server里面，注意，如果是部署在子目录，location /记得换成location /子目录名。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="attribute">if</span> (!-f <span class="variable">$request_filename</span>)&#123;  </span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$rule_0</span> <span class="number">1</span><span class="variable">$rule_0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="attribute">if</span> (!-d <span class="variable">$request_filename</span>)&#123;  </span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$rule_0</span> <span class="number">2</span><span class="variable">$rule_0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$rule_0</span> = <span class="string">"21"</span>)&#123;  </span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/([0-9A-Za-z]+)/?$</span> /yourls-go.php?id=<span class="variable">$1</span> <span class="literal">last</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/([0-9A-Za-z]+)\+/?$</span> /yourls-infos.php?id=<span class="variable">$1</span> <span class="literal">last</span>;  </span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/([0-9A-Za-z]+)\+all/?$</span> /yourls-infos.php?id=<span class="variable">$1</span>&amp;all=<span class="number">1</span> <span class="literal">last</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么做的原因是，由于官方使用的.htacess是基于apache的modrewrite模块，nginx并不使用，因此将官方给的转为nginx的规则，并加入conf文件。官方使用的.htacess来控制短链接缩短，所以需要这样一个配置，来确保服务生效。</p><h2 id="丰富的功能"><a href="#丰富的功能" class="headerlink" title="丰富的功能"></a>丰富的功能</h2><p>这个项目很有意思的一个地方是，它支持插件来扩展。并且也支持个人开发者写出更多插件，来丰富服务。例如官方自带的插件Random ShortURLs就是用于将链接转为随机链接使用的一款挺好用的插件。此外，也有很多很丰富的站点功能比如RSS支持、多域名支持、API支持以及spam功能。</p><blockquote><p>参考：</p><ul><li><a href="https://yrx.me/s/dsk74v" target="_blank" rel="noopener">http://o.xker.com/page/e2012/1114/121885.html</a></li><li><a href="https://yrx.me/s/z1wu6g" target="_blank" rel="noopener">https://www.xiaoz.me/archives/9887</a></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> 摸爬滚打 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 使用记录</title>
      <link href="/post/c81d9ccd/"/>
      <url>/post/c81d9ccd/</url>
      
        <content type="html"><![CDATA[<p>最近想把博客迁移到GitHub pages并且使用hexo的静态博客，以杜绝之前wordpress带来的资源占用和各种潜在的bug。。。<br>开一下这个来记录hexo的一些踩坑</p><h2 id="hexo链接唯一化"><a href="#hexo链接唯一化" class="headerlink" title="hexo链接唯一化"></a>hexo链接唯一化</h2><p>之前用wordpress时候用的是文章id，基本不用自己操心，hexo的默认url是日期+文章标题，这样带来的一个大问题是中文的情况下url可能在被转码之后很长，而且对我自己来说文章的url最好是在创建时就固定，而不是后面增删改动之后都变化一次，这样非常的不方便，因此寻找了一下链接唯一化的方法，参考以下两篇，感谢muyunyun&amp;rozbo两位的讲解。使用方法在第一篇里面。<br><a href="http://muyunyun.cn/posts/f55182c5/#%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5%E5%94%AF%E4%B8%80%E5%8C%96" target="_blank" rel="noopener">hexo 摸爬滚打之进阶教程</a><br><a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">rozbo/hexo-abbrlink</a></p><h2 id="启用评论"><a href="#启用评论" class="headerlink" title="启用评论"></a>启用评论</h2><p>之前wordpress习惯了评论系统（虽然没人评论）。。看到自带的主题里面有disqus不需要自己去动手就顺手开通了一下disqus的评论系统。</p><p>在cactus theme内开通比较简单，直接配置就好，后续可能研究一下如何使用valine系统。</p><h2 id="进行Google和Baidu的SEO"><a href="#进行Google和Baidu的SEO" class="headerlink" title="进行Google和Baidu的SEO"></a>进行Google和Baidu的SEO</h2><p>这里个人其实并不太了解Google和Baidu的SEO规则，之前wordpress时期都是靠插件来做的。这里安装了hexo sitemap这个插件来生成网站地图，并且自己提交到了Google和Baidu的search console。不得不说手动SEO果然比较累，这里贴一下参考的blog。</p><p><a href="https://www.jianshu.com/p/c20bb9df1867" target="_blank" rel="noopener">Hexo博客之后续SEO优化 via 时光丶flies</a></p><h2 id="coding和GitHub双线部署"><a href="#coding和GitHub双线部署" class="headerlink" title="coding和GitHub双线部署"></a>coding和GitHub双线部署</h2><p>由于GitHub pages在国内的访问速度过慢，而coding.nei也提供了pages服务，所以利用dnspod提供的双线dns解析服务，可以实现国内使用coding的快速服务，而国外使用GitHub的全球加速。</p><p>具体操作方法：<a href="http://muyunyun.cn/posts/f55182c5/#%E5%B0%86%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E5%92%8Ccoding" target="_blank" rel="noopener">hexo 摸爬滚打之进阶教程</a>。</p><p>有个要注意的点，dnspod设置解析线路规则是一定要设置默认线路，这里推荐默认线路为GitHub pages。coding pages的稳定性做的确实没有GitHub的好。</p><h2 id="中文字体优化"><a href="#中文字体优化" class="headerlink" title="中文字体优化"></a>中文字体优化</h2><p>cactus的原作者使用的字体没有兼容中文字体，而且个人不熟悉前端，因此参考了<a href="https://github.com/GetToSet" target="_blank" rel="noopener">GetToSet</a>对于他自己项目内的中文字体优化的commit<a href="https://github.com/GetToSet/hexo-theme-cactus/commit/19d05c9ca10f809132e136af152f7b19d8aa9e4b" target="_blank" rel="noopener">19d05c9</a>进行修改。在此对原作者表示感谢并致意！</p><h2 id="分享系统加入"><a href="#分享系统加入" class="headerlink" title="分享系统加入"></a>分享系统加入</h2><p>先上几个分享的api：</p><ol><li>分享到QQ空间接口：<a href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=你的网址&amp;sharesource=qzone&amp;title=你的分享标题&amp;pics=你的分享图片&amp;summary=你的分享描述信息" target="_blank" rel="noopener">https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=你的网址&amp;sharesource=qzone&amp;title=你的分享标题&amp;pics=你的分享图片&amp;summary=你的分享描述信息</a></li><li>分享给QQ好友接口：<a href="http://connect.qq.com/widget/shareqq/index.html?url=你的分享网址&amp;sharesource=qzone&amp;title=你的分享标题&amp;pics=你的分享图片地址&amp;summary=你的分享描述&amp;desc=你的分享简述" target="_blank" rel="noopener">http://connect.qq.com/widget/shareqq/index.html?url=你的分享网址&amp;sharesource=qzone&amp;title=你的分享标题&amp;pics=你的分享图片地址&amp;summary=你的分享描述&amp;desc=你的分享简述</a></li><li>分享到新浪微博接口：<a href="http://service.weibo.com/share/share.php?url=你的分享网址&amp;sharesource=weibo&amp;title=你的分享标题&amp;pic=你的分享图片&amp;appkey=你的key" target="_blank" rel="noopener">http://service.weibo.com/share/share.php?url=你的分享网址&amp;sharesource=weibo&amp;title=你的分享标题&amp;pic=你的分享图片&amp;appkey=你的key</a> （需要在新浪微博开放平台中申请）</li><li>分享到twitter接口：<a href="https://twitter.com/share?url=文章链接&amp;text=文章标题" target="_blank" rel="noopener">https://twitter.com/share?url=文章链接&amp;text=文章标题</a></li><li>分享到facebook接口：<a href="http://www.facebook.com/sharer.php?u=文章链接" target="_blank" rel="noopener">http://www.facebook.com/sharer.php?u=文章链接</a></li></ol><p>其中本站启用了QQ和微博的分享接口（由于QQ分享接口中是可以点击分享到空间的，因此并没有直接使用QQ空间的分享）微博的分享比较坑，需要自己去平台申请，还需要审核，放假了审核也放假，本站启用了微博，但是目前使用还不太正常。Facebook的有点特别，因为Facebook提出了一个<a href="https://ogp.me" target="_blank" rel="noopener">ogp</a>的标准，因此需要我们配置og tags之后在Facebook的分享中显示出站点标题和图片之类的信息，具体见<a href="https://blog.csdn.net/Edwin_/article/details/77089688" target="_blank" rel="noopener">网页中添加分享到Facebook via Edwin_</a></p><p>refer：<a href="https://zixuephp.net/article-309.html" target="_blank" rel="noopener">https://zixuephp.net/article-309.html</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>为一个博客花了大概三四天的样子，hexo总体上来说比较好玩，但是因为本身是纯静态的一个东西，很多操作要比wordpress繁琐很多，上手配置还是有点难度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 摸爬滚打 </tag>
            
            <tag> 上手记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10 UWP应用 解除网络隔离</title>
      <link href="/post/e7567473/"/>
      <url>/post/e7567473/</url>
      
        <content type="html"><![CDATA[<p>最近想给outlook加上Gmail的关联，但是发现网络连接一直有问题，代理好像一直没有正常的工作。但是对代理进行测试之后发现没有问题，于是去查了一下是不是UWP自身将很多东西ban掉。经过查证之后，发现确实是UWP自身运行于sandbox的问题，导致代理无法正常的使用。</p><blockquote><p>UWP 是微软在 Windows 10 中引入的新概念，由于所有 UWP 应用均运行在被称为 App Container 的虚拟沙箱环境中，其安全性及纯净度远胜于传统的 EXE 应用。但 App Container 机制同时也阻止了网络流量发送到本机（即 loopback）， 使大部分网络抓包调试工具无法对 UWP 应用进行流量分析。同样的，该机制也阻止了 UWP 应用访问 localhost，即使你在系统设置中启用了代理，也无法令 UWP 应用访问本地代理服务器，十分恼人。</p></blockquote><p><strong>UWP内部的OAuth需要同时激活另外的AuthHost这个服务的网络流量</strong><br>只考虑邮件和日历的话，开启以下3个App的Lookback流量代理就可以正常访问谷歌账号了:</p><ul><li>microsoft.windows.authhost.a_ 8wekyb3d8bbwe</li><li>电子邮件和账户 </li><li>邮件和日历</li></ul><p>在网上找了一下解决方案，这里记录下来mark一下。<br><a href="https://sspai.com/post/41137" target="_blank" rel="noopener" title="通过设置为 Win 10 UWP 应用解除网络隔离">通过设置为 Win 10 UWP 应用解除网络隔离 via Umi</a></p><h2 id="使用win10自带的CheckNetIsolation-exe-的命令行工具"><a href="#使用win10自带的CheckNetIsolation-exe-的命令行工具" class="headerlink" title="使用win10自带的CheckNetIsolation.exe 的命令行工具"></a>使用win10自带的CheckNetIsolation.exe 的命令行工具</h2><blockquote><p>CheckNetIsolation.exe 的命令行工具可以帮助我们将 UWP 及 Windows 8 Metro 应用添加到排除列表</p></blockquote><h3 id="1-通过注册表获取应用的-SID"><a href="#1-通过注册表获取应用的-SID" class="headerlink" title="1.通过注册表获取应用的 SID"></a>1.通过注册表获取应用的 SID</h3><p>首先通过<code>Win + R</code> 快捷键打开「运行」窗口，输入「Regedit」打开注册表编辑器，然后定位到 <code>HKEY_CURRENT_USER\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings</code> ，接着在左边的注册表项中找到你想解除网络隔离的应用，右边的 DisplayName 就是应用名称，而左边那一大串字符就是应用的 SID 值了。<br><img src="https://cdn.sspai.com/2017/09/30/358ecf1cdd6a6a5a7a7dfdf2c281fe03.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="注册表编辑器" title="注册表编辑器"></p><h3 id="2-打开-CMD-面板"><a href="#2-打开-CMD-面板" class="headerlink" title="2.打开 CMD 面板"></a>2.打开 CMD 面板</h3><p>在终端中输入 <code>CheckNetIsolation.exe loopbackexempt -a -p=SID</code>，出现「完成」后就大功告成了。记得这里要用管理员权限。</p><p><img src="https://cdn.sspai.com/2017/09/30/9c27d33ad26dbd0ca63eee0d00fce9af.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="cmd"></p><h2 id="通过fiddler来设置"><a href="#通过fiddler来设置" class="headerlink" title="通过fiddler来设置"></a>通过fiddler来设置</h2><p>上面的命令行工具对于普通用户来说可能太过繁琐，这里有一种简单的解决方法，<a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">fiddler 4</a>是一款windows下用户抓取HTTP数据包的一个软件，这款软件内部自带了一个Win config工具用来解除网络隔离。<br>下载安装完成之后，打开软件，点击左上角的winconfig<br><img src="/assets/pics/WinConfig%E5%B7%A5%E5%85%B7-1024x549.png" alt="WinConfig工具"><br>打开工具后，以电子邮件为例，如下图勾选一下几个服务就可以啦。<br><img src="/assets/pics/%E9%9C%80%E8%A6%81%E5%8B%BE%E9%80%89%E7%9A%84%E4%B8%9C%E8%A5%BF-400x1024.png" alt="需要勾选的部分"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是这个问题的配置解决方案，要注意一下就是win10的Auth服务似乎是单独的一个进程，所以在使用Todoist或者是Outlook的Google认证的时候，如果要使用代理，记得把最开始里面说的那个auth服务也勾选上或者添加上去。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> 摸爬滚打 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitignore中途添加规则失效</title>
      <link href="/post/85b2a04/"/>
      <url>/post/85b2a04/</url>
      
        <content type="html"><![CDATA[<p>好久没有自定义过gitignore了，最近自己写了点小东西，然后传git的时候发现gitignore失效，数据库的配置文件还是被传上去了，这才发现gitignore有个小坑。这里先说一下gitignore的两种情况</p><h2 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h2><p>项目初始化时写gitignore 然后再开始增加后面的修改 这样做在后续的版本控制中 自然会忽略掉我们不想带上远程库的文件</p><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>项目开始的时候 没有将一些无关文件配置进.gitignore里面。导致文件已经进行跟踪了，但是目前想把这些文件add 到.gitignore文件中，但是发现没有效果。 修改文件之后，git 依然检测到了，文件改动，然后将文件上传到了远程库</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>git有一条规则：“如果一个文件一开始没有添加到.gitignore里面，中途添加进去。git将不会忽略这个文件”。因此，需要用<code>git rm --cached &lt;file name&gt;</code>这条命令来将文件的版本控制追踪清除掉。但是要注意，清除掉缓存的版本控制追踪后，需要重新<code>git add/commit/push</code>。这样就可以使改动后的gitignore生效了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 摸爬滚打 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈线程安全与否之重要性</title>
      <link href="/post/a043706b/"/>
      <url>/post/a043706b/</url>
      
        <content type="html"><![CDATA[<p><del>很久没有写过博客了，这算是一年来第一篇公开的博客来着</del><br><strong>开宗明义，先上一篇我觉得很棒的博客</strong><br><a href="https://www.cnblogs.com/wxd0108/p/5479442.html" target="_blank" rel="noopener" title="Java中的多线程你只要看这一篇就够了">Java中的多线程你只要看这一篇就够了</a><br>先介绍为什么会出现线程不安全的情况：计算机在执行多线程任务的时候，如果所能调度的只有单核，那么实际上的物理执行为：线程A执行部分过后暂停，然后线程B继续执行。这时，如果程序有全局变量或者静态变量的存在，同时两个线程内有对于全局或者静态变量的操作，那么很有可能导致的情况就就是两个线程在执行的时候，发生在对于同一个全局变量进行操作之后，主线程的内存被更新，而同时，子线程内存未更新而就开始进行操作操作以至于拿到不同的结果。例如如下代码：<br>count.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            num += i;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-"</span> + num);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            Count count = <span class="keyword">new</span> Count();  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                count.count();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">new</span> Thread(runnable).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，可以发现，结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0-165</span><br><span class="line">Thread-1-275</span><br><span class="line">Thread-6-220</span><br><span class="line">Thread-3-165</span><br><span class="line">Thread-2-165</span><br><span class="line">Thread-5-385</span><br><span class="line">Thread-8-495</span><br><span class="line">Thread-4-330</span><br><span class="line">Thread-7-440</span><br><span class="line">Thread-9-550</span><br></pre></td></tr></table></figure><p>可以看到，每个线程输出的数字都不太一样，在最后输出了550，也就是十个线程递增的结果。<br>而不是我们所期望的每个线程都输出55<br>那么为什么会造成这种情况呢？<br>答案是因为，CPU在执行多线程任务的时候，每个线程并非可以独立占用一个CPU，而是将一段代码分成几部分，然后各个线程的部分代码交替执行。<br>例如这里的子线程操作，一共如下几个步骤：</p><ol><li>读取主线程中count对象到子线程内存中。</li><li>子线程操作引擎执行操作代码</li><li>将计算结果从子线程内存中刷新到主线程</li></ol><p>但是在多线程的情况下，可能出现的情况为<br>线程1-1，线程2-1，线程1-2，线程1-3，线程2-3 或者其他的排序，因为CPU具体在执行代码的时候，会对于操作进行重排序，而排序情况是不确定的。<br>对此就引申出多线程几个重要的概念：</p><ul><li><p>原子性：是指一个操作是不可中断的。即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。比如，对于一个静态全局变量int i，两个线程同时对它赋值，线程A给他赋值为1，线程B给他赋值为-1。那么不管这两个线程以何种方式。何种步调工作，i的值要么是1，要么是-1.线程A和线程B之间是没有干扰的。这就是原子性的一个特点，不可被中断。</p></li><li><p>可见性：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，对于串行来说，可见性问题是不存在的。</p></li><li><p>有序性：在并发时，程序的执行可能会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。有序性问题的原因是因为程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。</p></li></ul><p>而线程不安全，就是违背了三个特性中的某一个特性而导致的输出非预期输出或其他问题。同时，解决线程的安全性与否，亦是从上面三个性质入手开始解决。例如之前的例子，便是由于count对象的num变量是成员变量，同时count对象是主线程内共享的，因此导致的问题就是上一个线程执行完以后，下一个线程拿到了count对象，并且读到了其成员变量num被修改过的值，所以导致了数字是累加而不是每个线程独立运算结果。<br>解决的方法有两种，第一个是将Count类里面的num作为局部变量使用，第二个是将count对象放在run方法里面，也就是将成员变量和共享的全局变量，改为局部变量。<br>我们将这个问题引申，当我们在写Java Web的代码时，由于Servlet接口是单实例，多线程的运行方式，也就是每个请求进来以后，单独开一个线程对于请求进行处理。但是由于上面所说，对于每个请求都是单实例但是多线程的方式，如果在Servlet中有了一个共享的成员变量或者全局变量，这样就会导致如果有线程在调用实例之后，对成员变量进行修改，那么另一个线程在调用实例时，并不知道成员变量被修改，而是遵循原来的逻辑直接输出，这样就会导致同样的输入可能得到不同的结果。<br>对此，我们有了第一种解决方法，因为被修改之后，下一个线程不一定能及时的拿到主线程内存的更新状态，因此我们需要做的便是，保持成员变量或全局变量的更新。这里引入<strong>volatile</strong>关键字。<br>定义:volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">" j="</span> + j);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>one方法和two方法还会并发的去执行，但是加上volatile可以将共享变量i和j的改变直接响应到主内存中，这样保证了主内存中i和j的值一致性，然而在执行two方法时，在two方法获取到i的值和获取到j的值中间的这段时间，one方法也许被执行了好多次，导致j的值会大于i的值。所以volatile可以保证内存可见性，不能保证并发有序性。<br>第二种解决方法便是synchronized关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraditionalThreadSynchronized</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">final</span> Outputter output = <span class="keyword">new</span> Outputter();  </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                output.output(<span class="string">"zhangsan"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();        </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                output.output(<span class="string">"lisi"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outputter</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO 为了保证对name的输出不是一个原子操作，这里逐个输出name的每个字符  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; name.length(); i++) &#123;  </span><br><span class="line">            System.out.print(name.charAt(i));  </span><br><span class="line">            <span class="comment">// Thread.sleep(10);  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用synchronized将需要互斥的代码包含起来，并上一把锁。</li><li>将synchronized加在需要互斥的方法上。</li></ol><h3 id="对于Servlet中的线程安全问题"><a href="#对于Servlet中的线程安全问题" class="headerlink" title="对于Servlet中的线程安全问题"></a>对于Servlet中的线程安全问题</h3><p>1，变量的线程安全：这里的变量指字段和共享数据(如表单参数值)。</p><p>  a，将 参数变量 本地化。多线程并不共享局部变量.所以我们要尽可能的在servlet中使用局部变量。<br>   例如：String user = “”;<br>         user = request.getParameter(“user”);</p><p>  b，使用同步块Synchronized，防止可能异步调用的代码块。这意味着线程需要排队处理。<br>  在使用同板块的时候要尽可能的缩小同步代码的范围，不要直接在sevice方法和响应方法上使用同步，这样会严重影响性能。</p><p> 2,属性的线程安全：ServletContext，HttpSession，ServletRequest对象中属性<br>  ServletContext：（线程是不安全的）<br>   ServletContext是可以多线程同时读/写属性的，线程是不安全的。要对属性的读写进行同步处理或者进行深度Clone()。<br>   所以在Servlet上下文中尽可能少量保存会被修改（写）的数据，可以采取其他方式在多个Servlet中共享，比方我们可以使用单例模式来处理共享数据。<br>  HttpSession：（线程是不安全的）<br>   HttpSession对象在用户会话期间存在，只能在处理属于同一个Session的请求的线程中被访问，因此Session对象的属性访问理论上是线程安全的。<br>   当用户打开多个同属于一个进程的浏览器窗口，在这些窗口的访问属于同一个Session，会出现多次请求，需要多个工作线程来处理请求，可能造成同时多线程读写属性。<br>   这时我们需要对属性的读写进行同步处理：使用同步块Synchronized和使用读/写器来解决。</p><p>  ServletRequest：（线程是安全的）<br>   对于每一个请求，由一个工作线程来执行，都会创建有一个新的ServletRequest对象，所以ServletRequest对象只能在一个线程中被访问。ServletRequest是线程安全的。<br>   注意：ServletRequest对象在service方法的范围内是有效的，不要试图在service方法结束后仍然保存请求对象的引用。</p><p> 3，使用同步的集合类：<br>  使用Vector代替ArrayList，使用Hashtable代替HashMap。</p><p> 4，不要在Servlet中创建自己的线程来完成某个功能。<br>  Servlet本身就是多线程的，在Servlet中再创建线程，将导致执行情况复杂化，出现多线程安全问题。</p><p> 5，在多个servlet中对外部对象(比方文件)进行修改操作一定要加锁，做到互斥的访问。<br> PS：SingleThreadModel接口亦可以 只不过已经被弃用</p><h3 id="Spring中的线程安全问题"><a href="#Spring中的线程安全问题" class="headerlink" title="Spring中的线程安全问题"></a>Spring中的线程安全问题</h3><ol><li>对操作共享变量的所用方法进行同步控制； </li><li>同步共享变量，例如Collections.synchronizedMap()可以同步共享的Map。 </li><li>使用同步对象，例如ConcurrentMap、AtomicInteger等对象都是线程安全的，使用AtomicInteger可以统计系统的并发量。</li></ol><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><ol><li>多关注集合类，比如HashMap，ArrayList等，这些对象经常会发生内存泄露。比如当它们被声明为静态对象时，它们的生命周期会跟应用程序的生命周期一样长，很容易造成内存不足。</li><li>多关注事件监听（listeners）和回调（callbacks），比如注册了一个listener，当它不再被使用的时候，忘了注销该listener，可能就会产生内存泄露。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客重建完成</title>
      <link href="/post/82ee9938/"/>
      <url>/post/82ee9938/</url>
      
        <content type="html"><![CDATA[<p>鸽了一年了终于把去年自己删掉的博客弄回来。<br>以后这里可能写点瞎想的技术和其他的感想吧。<br>还是觉得很有意思的没事干写点博客。立个flag，以后我也要写周报了，然后放这。。。<br>wordpress讲道理还是好用，就是有点瓜，其他都还行。<br>最后送大家一句话吧，<strong>没有命运，只有选择</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 瞎扯 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
